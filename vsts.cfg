// Vslot Text Sender & Vshader Editor by Salatiel (v 27/04/2025)

vsts_attribute_get = [arg2 = (concatword $arg2 ":"); arg2 = (substr $arg1 (+ (strstr $arg1 $arg2) (strlen $arg2))); substr $arg2 0 (strstr $arg2 "|")]
vsts_attribute_edit = [
	strreplace $arg1 (concatword $arg2 ":" (vsts_attribute_get $arg1 $arg2) "|") (concatword $arg2 ":" $arg3 "|")
]

vsts_string_to_code = [
	loopconcatword s (strlen $arg1) [
		local n
		n = (strcode $arg1 $s)
		format "%1%2" $n (loopconcatword p (- 3 (strlen $n)) [result "!"])
	]
]

// this is a culprit for bad fps, if you have any ideas on how to improve this, let me know.
vsts_code_to_string = [
	loopconcatword c (strlen $arg1) [ codestr (substr $arg1 (* $c 3) 3) ]
]

vsts_write = [
	local coded i d coded_unique param_length
	coded = (vsts_string_to_code $arg1)
	i = 0
	d = 0
	param_length = (? (=s $arg3 "") 250 $arg3)

	// vshaderparam does not allow duplicate names, so we introduce variations
	if (!= $arg2 1) [
		while [<= $d (strlen $coded)] [
			if (> (rnd 100) 50) [
				appendword coded_unique "-"
			] [
				appendword coded_unique (substr $coded $d 1)
				d = (+ $d 1)
			]
		]
		coded = $coded_unique
	]

	vdelta [
		while [<= $i (strlen $coded)] [
			vshaderparam (format "%1%2%3" (? (= $i 0) "[" "") (substr $coded $i $param_length) (? (>= (+ $i $param_length) (strlen $coded)) "]" ""))
			i = (+ $i $param_length)
		]
	]
	compactvslots
]

vsts_join = [
	local paramnames
	paramnames = (strreplace (strreplace (getvshaderparamnames $arg1) "-" "") " " "")
	//strreplace (strreplace (strreplace (strreplace (strreplace (strreplace (getvshaderparamnames $arg1) "-" "") " " "") "trigger" "") "radius" "") "geometrypivot" "") "geometryposition" ""
	looplist customuniform $_vshe_mapshader_uniforms [
		local shadername
		shadername = (at $_vshe_mapshader_uniforms 0)
		paramnames = (strreplace $paramnames $shadername "")
	]
	result $paramnames
]

vsts_get_by_slot = [
	local params
	params = (vsts_join $arg1)
	result $params
]

vsts_get_by_match = [
	compactvslots
	local code_match search_slot all_slots match_start match_end
	code_match = (vsts_string_to_code $arg1)
	search_slot = (numslots) // num of registered textures
	match_start = $arg2
	match_end = $arg3

	all_slots = []

	while [<= $search_slot (numvslots)] [
		append all_slots (looplistconcat s (vsts_get_by_slot $search_slot) [result (format "[%1]" $s)])
		search_slot = (+ $search_slot 1)
	]
	
	? (!=s $code_match "") (listfilter m $all_slots [!= (strstr (? (=s $match_start "") $m (substr $m $match_start $match_end)) $code_match) -1]) $all_slots
]

vsts_read = [
	local by_slot by_match final_result
	by_slot = (vsts_get_by_slot $arg1)
	by_match =  (vsts_get_by_match $arg1 $arg2 $arg3)
	final_result = (looplistconcat str (concat (listfilter bs $by_slot [= (strstr $by_match $bs) -1]) $by_match) [format "[%1]" (vsts_code_to_string $str)])
	result $final_result
]

vsts_textsave = [
	local file
	if (=s $_vshe_gui_editor_file "") [ _vshe_gui_editor_file = (concatword "vsts_custom_" (getmillis) ".cfg") ]

	if (= (strstr $_vshe_gui_editor_file ".") -1) [
		if (&& (= (strstr $textshow "//@fragment") -1) (= (strstr $textshow "//@vertex") -1)) [
			_vshe_gui_editor_file = (concatword $_vshe_gui_editor_file ".cfg")
		] [
			_vshe_gui_editor_file = (concatword $_vshe_gui_editor_file ".glsl")
		]
	]

	file = (concatword "vsts/" $_vshe_gui_editor_file)
	textsave $file
	if (findfile $file) [
		_vsts_echo (concat $file "saved successfully")
		sound 11
	] [
		_vsts_warn (concat "^f3" $file "could not be saved")
	]
]

vsts_textload = [
	local file saved_files filtered_start filtered_end has_ext
	
	has_ext = (strstr $textshow ".cfg")
	saved_files = []

	loopfiles sf "vsts" "" [
		if (&& (!=s $sf "..") (!=s $sf ".") (!= (strstr $sf ".") -1)) [
			sf = (escape $sf)
			append saved_files $sf
		]
	]

	filtered_start = (listfilter sf $saved_files [!= (strstr $sf (substr $_vshe_gui_editor_file 0 (? (!= $has_ext -1) $has_ext (strlen $_vshe_gui_editor_file)) )) -1])
	filtered_end = (listfilter sf $saved_files [= (strstr $sf (substr $_vshe_gui_editor_file 0 (? (!= $has_ext -1) $has_ext (strlen $_vshe_gui_editor_file)))) -1])
	saved_files = (concat $filtered_start $filtered_end)
	file = (concatword "vsts/" (at $saved_files 0))

	if (findfile $file) [
		textload $file
		if (!=s $textshow "") [
			_vsts_echo (concat $file "loaded successfully")
		] [
			_vsts_warn (concat "^f3" $file "loaded but is empty")
		]
		_vshe_gui_editor_file = (strreplace $file "vsts/" "")
	] [
		_vsts_warn (concat "^f3" $file "could not be found")
	]
	sound 11
]

_vsts_echo = [
	echo (format "^f7[VSTS-0.1^f~] %1" $arg1)
]

_vsts_warn = [
	_vsts_echo (concatword "^f2" $arg1)
	if (=s $arg2 "") [
		sound 3
	] [sound $arg2]
]

_vshe_gui_tempwarn = ""
_vshe_gui_tempwarnseconds = 0
_vshe_gui_repeat_delay = 0
_vshe_gui_dorepeat = [
	if (< $_vshe_gui_repeat_delay (getmillis 1)) [
		_vshe_gui_repeat_delay = (+ (getmillis 1) @arg1)
		@arg2

		if (= $_vshe_gui_tempwarnseconds 0) [
			_vshe_gui_tempwarn = ""
		] [
			_vshe_gui_tempwarnseconds = (- $_vshe_gui_tempwarnseconds 1)
		]
	]
]

vshe_encode = [
	arg1 = (vsts_string_to_code $arg1)
	arg2 = (vsts_string_to_code $arg2)
	arg3 = (vsts_string_to_code $arg3)
	arg4 = (vsts_string_to_code $arg4)
	arg5 = (vsts_string_to_code $arg5)
	vsts_write (format "uniqueid:%1|author:%2|desc:%3|body:%4|path:%5|" $arg1 $arg2 $arg3 $arg4 $arg5)
]

if (=s (getalias "_vshe_storage_local") "") [
	_vshe_storage_local = []
]

// handles addition and modification
_vshe_storage_local_update = [

	// we don't want duplicates
	_vshe_storage_local_remove (vsts_code_to_string (vsts_attribute_get $arg1 "uniqueid"))

	append _vshe_storage_local $arg1

	sleep 0 [_vshe_mapshader_refresh]
]

// receives an id
_vshe_storage_local_remove = [
	sound 10
	_vshe_storage_local = (listfilter s $_vshe_storage_local [
		local uniqueid
		uniqueid = (vsts_code_to_string (vsts_attribute_get $s "uniqueid"))
		!= $uniqueid $arg1
	])
	_vshe_mapshader_refresh
]

_vshe_storage_local_indexof = [
	indexof $_vshe_storage_local $arg1
]

_vshe_storage_public_indexof = [
	indexof $_vshe_storage_public $arg1
]

_vshe_storage_public = []
_vshe_storage_public_load = [
	_vshe_mapshader_refresh
	local decoded_string
	decoded_string = (looplistconcat m (vsts_get_by_match "uniqueid" 0 24) [vsts_code_to_string $m])
	_vshe_storage_public = []
	looplist ds $decoded_string [
		if (= (indexof $_vshe_storage_public $ds) -1) [
			append _vshe_storage_public $ds
		]
	]
]

_vshe_fetch_attributes = [
	local uniqueid author model desc body path

	uniqueid = (vsts_code_to_string (vsts_attribute_get $arg1 "uniqueid"))

	if (=s $uniqueid "") [
		uniqueid = "^f3unknown"
		_vsts_warn "^f3error: could not find slot uniqueid"
	]

	author = (at (vsts_code_to_string (vsts_attribute_get $arg1 "author")) 0)
	if (=s $author "") [
		author = "unnamed"
	]

	model = (at (vsts_code_to_string (vsts_attribute_get $arg1 "author")) 1)
	desc = (vsts_code_to_string (vsts_attribute_get $arg1 "desc"))
	body = (vsts_code_to_string (vsts_attribute_get $arg1 "body"))
	path = (vsts_code_to_string (vsts_attribute_get $arg1 "path"))
	if (=s $path "") [
		path = $_vshe_gui_editor_file
	]
]

_vshe_share = [
	if (&& (!= (havesel) 0) (!=s (getseltex) "")) [
		_vshe_storage_local_remove (vsts_code_to_string (vsts_attribute_get $arg1 "uniqueid"))
		arg1 = (vsts_attribute_edit $arg1 "uniqueid" (vsts_string_to_code (+ (rnd (getmillis)) (getmillis 1))))
		_vshe_gui_editor_newslot = $arg1
		_vshe_storage_local_update $arg1
		vsts_write $arg1
	] [
		_vshe_gui_tempwarn = "^f2you must select a geometry to store the content"
		_vshe_gui_tempwarnseconds = 3
		if $editing [
			_vsts_warn "you must select a geometry to store the content"
		] [
			_vsts_warn "you must enter edit mode and select a geometry to store the content"
		]
	]
]

_vshe_gui_default_body = "//@id 5^n^n//@fragment^ncolor = vec4(0, 0, 1, 0);^n^n//@vertex^nposition.z += 16;"
_vshe_gui_editor_file = "vsts_custom.glsl"
_vsts_gui_editor_file_lasttextshow = ""
_vsts_gui_editor_body_lasttextshow = ""
_vshe_gui_notepad_keep = 0
_vshe_gui_has_trigger_preview = 0

_vshe_gui_notepad = [
	_vshe_gui_notepad_keep = 1
	if (=s $arg1 "") [
		arg1 = (format "uniqueid:%1|author:%2|desc:%3|body:%4|path:%5|" (vsts_string_to_code (+ (rnd (getmillis)) (getmillis 1))) (vsts_string_to_code (concat $getname $playermodel)) (vsts_string_to_code "my new slot") (vsts_string_to_code $_vshe_gui_default_body) (vsts_string_to_code $_vshe_gui_editor_file))
	]

	_vshe_gui_editor_newslot = $arg1

	if $editing [
		if (&& (!= (havesel) 0) (!=s (getseltex) "")) [
			_vshe_gui_editor_trigger_pos = (looplistconcat p (getvshaderparam (getseltex) "trigger") [abs $p])
			_vshe_gui_editor_trigger_radius = (looplistconcat p (getvshaderparam (getseltex) "triggerradius") [abs $p])
		]
	]
	if (=s $_vshe_gui_editor_trigger_pos "") [
		_vshe_gui_editor_trigger_pos = "512 512 512 5"
	]
	if (=s $_vshe_gui_editor_trigger_radius "") [
		_vshe_gui_editor_trigger_radius = "10 10 30 0"
	]

	@_vshe_fetch_attributes

	newgui vshe_notepad [arg1 = @arg1; guistayopen [guinoautotab [
		if (&& (! $editing) $_vshe_gui_has_trigger_preview) [ clearpostfx ]
		//arg1 = $_vshe_gui_editor_newslot
		
		@_vshe_fetch_attributes
		
		guilist [
			guilist [
				guitext "^f2last author" 0
				guitext "^f2description" 0
				guistrut 1
				if $editing [
					guitext (format "^f%1trigger pos" (? (&& (!= $havesel 0) (!=s $getseltex "")) 6 4)) 0
					guitext (format "^f%1trigger size" (? (&& (!= $havesel 0) (!=s $getseltex "")) 6 4)) 0
				] [
					guitext "^f4trigger pos" 0
					guitext "^f4trigger size" 0
				]
			]
			guistrut 1
			guilist [
				guilist [
					guiimage (concatword "packages/icons/" (playermodelicon $model) ".jpg") [goto (getclientnum @author)] 0.5 0
					guitextbox $author 28 0 0xbbddbb
				]

				guifield _vshe_gui_editor_description_value -40 [
					_vshe_gui_editor_newslot = (vsts_attribute_edit $_vshe_gui_editor_newslot "desc" (vsts_string_to_code $_vshe_gui_editor_description_value))
				]

				guistrut 1
				guilist [
					guifield _vshe_gui_editor_trigger_pos 20 [
						if $editing [
							if (&& (!= $havesel 0) (!=s $getseltex "")) [
								vdelta [
									vshaderparam "trigger" @_vshe_gui_editor_trigger_pos
								]
								_vshe_draw_box_postfx @_vshe_gui_editor_trigger_pos @_vshe_gui_editor_trigger_radius
							] [
								_vsts_warn "you must select a geometry to set the trigger position/id"
							]
						] [
							_vsts_warn "you must enter edit mode to set the trigger position/id for selected geometry"
						]
					]
					guistrut 1
					guitext "^f7(^f1x ^f0y ^f3z ^f8id^f7)" 0
					guistrut 1
					guibutton "^f0[getcampos]" [
						_vshe_gui_editor_trigger_pos = (format "%1 %2 %3 %4" (abs (round (at (getcampos) 0))) (abs (round (at (getcampos) 1))) (- (at (getcampos) 2) 7) (abs (at $_vshe_gui_editor_trigger_pos 3)))
					] 0
				]
				guistrut -1
				guilist [
					guistrut 0.5
					if (=s $textfocus "_vshe_gui_editor_trigger_pos") [
						guitextbox (format "^f1%1 ^f0%2 ^f3%3 ^f8%4" (at $textshow 0) (at $textshow 1) (at $textshow 2) (at $textshow 3)) 25 0
					] [
						local guitextbox_valid_input
						guitextbox_valid_input = [guitextbox (format "^f1%1 ^f0%2 ^f3%3 ^f8%4" (at $_vshe_gui_editor_trigger_pos 0) (at $_vshe_gui_editor_trigger_pos 1) (at $_vshe_gui_editor_trigger_pos 2) (at $_vshe_gui_editor_trigger_pos 3)) 25 0]
						if $editing [
							if (=s (getvshaderparam (getseltex) "trigger") "") [
								guilist [
									guitextbox (format "%1" $_vshe_gui_editor_trigger_pos) 25 0 0x223322
									guistrut -1
									guilist [
										guistrut 15
										guitextbox "^f0[apply]" 20 0
									]
								]
							] [@guitextbox_valid_input]
						] [ @guitextbox_valid_input ]
					]
				]

				guilist [
					guifield _vshe_gui_editor_trigger_radius 20 [
						if $editing [
							if (&& (!= $havesel 0) (!=s $getseltex "")) [
								vdelta [
									vshaderparam "triggerradius" @_vshe_gui_editor_trigger_radius
								]
								_vshe_draw_box_postfx @_vshe_gui_editor_trigger_pos @_vshe_gui_editor_trigger_radius
							] [
								_vsts_warn "you must select a geometry to set the trigger radius"
							]
						] [
							_vsts_warn "you must enter edit mode to set the trigger radius for selected geometry"
						]
					]
					guistrut 1
					guitext "^f7(^f1width ^f0depth ^f3height^f7)" 0
				]
				guistrut -1
				guilist [
					guistrut 0.5
					if (=s $textfocus "_vshe_gui_editor_trigger_radius") [
						guitextbox (format "^f1%1 ^f0%2 ^f3%3 ^f4%4" (at $textshow 0) (at $textshow 1) (at $textshow 2) (at $textshow 3)) 25 0
					] [
						local guitextbox_valid_input
						guitextbox_valid_input = [guitextbox (format "^f1%1 ^f0%2 ^f3%3 ^f4%4" (at $_vshe_gui_editor_trigger_radius 0) (at $_vshe_gui_editor_trigger_radius 1) (at $_vshe_gui_editor_trigger_radius 2) (at $_vshe_gui_editor_trigger_radius 3)) 25 0]
						if $editing [
							if (=s (getvshaderparam (getseltex) "triggerradius") "") [
								guilist [
									guitextbox (format "%1" $_vshe_gui_editor_trigger_radius) 25 0 0x223322
									guistrut -1
									guilist [
										guistrut 15
										guitextbox "^f0[apply]" 20 0
									]
								]
							] [@guitextbox_valid_input]
						] [ @guitextbox_valid_input ]
					]
				]
			]
		]
		guistrut 0.5
		guilist [
			guifield _vshe_gui_editor_file -30 [
				_vshe_gui_editor_file = (strreplace (strreplace $_vshe_gui_editor_file ">" "") "<" "")
				_vshe_gui_editor_newslot = (vsts_attribute_edit $_vshe_gui_editor_newslot "path" (vsts_string_to_code $_vshe_gui_editor_file))
			]
			
			guistrut 1
			guibutton "^f8[load]" [
				vsts_textload
				_vshe_gui_editor_newslot = (vsts_attribute_edit $_vshe_gui_editor_newslot "body" (vsts_string_to_code $textshow))
				_vshe_gui_editor_newslot = (vsts_attribute_edit $_vshe_gui_editor_newslot "path" (vsts_string_to_code $_vshe_gui_editor_file))
			] 0
			guistrut 1
			guibutton "^f8[save file]" [
				vsts_textsave
			] 0
		]
		guistrut 52 1
		guilist [
			guieditor _vshe_gui_editor_body_value -50 10
			guistrut -2
		]
		if (=s $textfocus "_vshe_gui_editor_body_value") [
			if (=s $textshow $_vshe_gui_default_body) [
				guistrut -10
				guilist [
					guistrut 0.5
					guitextbox "^f~//^f1@id ^f85 ^f4<- identifier used to activate this shader.^n^n^f~//^f2@fragment ^f4<- sets the color of each pixel on the screen.^n^f2color = vec4(0, 0, 1, 0);^n^n^f~//^f6@vertex ^f4<- adjusts the position of points on the screen.^n^f6position.z += 16;" 50 10 0xffffff
				]
			]
		]

		_vshe_gui_dorepeat 200 [
			if (&& (=s $textfocus "_vshe_gui_editor_body_value") (!=s $textshow $_vsts_gui_editor_body_lasttextshow)) [
				_vshe_gui_editor_newslot = (vsts_attribute_edit $_vshe_gui_editor_newslot "body" (vsts_string_to_code $textshow))
				_vsts_gui_editor_body_lasttextshow = $textshow
			]
		]
		guistrut -1
		guialign 0 [
			if (=s $textfocus "_vshe_gui_editor_body_value") [
				if (!= (strstr $_vshe_gui_editor_file ".cfg") -1) [
					guibutton "^f5(run cubescript)" [
						do $textshow
					] 0
					guistrut 1
				]
			]
			guibutton "^f8[select]" [ textselectall ] 0
			guistrut 1
			guibutton "^f8[copy]" [ textselectall; textcopy ] 0
			guistrut 1
			guibutton "^f8[paste]" [ textpaste ] 0
		]

		guilist [
			if (=s (vsts_attribute_get $_vshe_gui_editor_newslot "body") "") [
				guitext "^f4body content is required" 0;
			] [
				// slot is not locally saved
				if (= (_vshe_storage_local_indexof $_vshe_gui_editor_newslot) -1) [
					// slot is not locally saved & is changed
					if (!=s $_vshe_gui_editor_newslot $arg1) [
						guibutton "^f0[save changes & allow]" [
							_vshe_gui_editor_newslot = (vsts_attribute_edit $_vshe_gui_editor_newslot "author" (vsts_string_to_code (format "%1 %2" (getname) $playermodel)))
							_vshe_storage_local_update $_vshe_gui_editor_newslot
							arg1 = $_vshe_gui_editor_newslot
							vsts_textsave
						] 0
						guitext "^f4 - you have unsaved changes" 0
					] [
						guiimage "<grey><mad:1/0.5/0.5><rotate:2>packages/particles/base.png" [] 0.5 0
						guibutton "^f0[allow]" [
							_vshe_storage_local_update $arg1
							vsts_textsave
						] 0
						guitext "^f4 - not active, not saved locally" 0
					]
				] [
					// slot is locally saved but is not public yet
					if (= (_vshe_storage_public_indexof $_vshe_gui_editor_newslot) -1) [
						@_vshe_fetch_attributes
						guiimage "<grey><mad:2/2/0.3><rotate:2>packages/particles/base.png" [] 0.5 0
						guibutton "^f2[share from local save]" [
							_vshe_share $_vshe_gui_editor_newslot
							cleargui
							showgui vshadereditor
						] 0
						guistrut 0.5
						guitext "^f4 - you haven't shared it publicly" 0
					] [
						// slot is locally saved and is public
						guiimage "<grey><mad:0.5/2/0.5><rotate:2>packages/particles/base.png" [] 0.5 0
						guibutton "^f3[disable]" [
							_vshe_storage_local_remove @uniqueid
						] 0
						guistrut 0.5
						guitext "^f4 - local copy is up to date with public" 0
					]
				]
			]
		]
		
		if (=s $textfocus "_vshe_gui_editor_file") [
			local saved_files filtered_start filtered_end has_ext filtered_textshow files_length
			
			saved_files = []
			has_ext = (strstr $textshow ".cfg")
			filtered_textshow = (strreplace (strreplace $textshow ">" "") "<" "")
			files_length = 9

			loopfiles sf "vsts" "" [
				if (&& (!=s $sf "..") (!=s $sf ".") (!= (strstr $sf ".") -1)) [
					sf = (escape $sf)
					append saved_files $sf
				]
			]
			filtered_start = (listfilter sf $saved_files [!= (strstr $sf (substr $filtered_textshow 0 (? (!= $has_ext -1) $has_ext (strlen $filtered_textshow)) )) -1])
			filtered_end = (listfilter sf $saved_files [= (strstr $sf (substr $filtered_textshow 0 (? (!= $has_ext -1) $has_ext (strlen $filtered_textshow)))) -1])
			saved_files = (concat $filtered_start $filtered_end)
			if (!=s $textshow $_vsts_gui_editor_file_lasttextshow) [
				local sum_page sub_page
				sum_page = (listlen (_strstrlist $textshow ">"))
				sub_page = (listlen (_strstrlist $textshow "<"))
				if (&& (= $sum_page 0) (= $sub_page 0)) [
					_curtabvsts_savedfiles = 0
				]
				_curtabvsts_savedfiles = (- $sum_page $sub_page)
				_vsts_gui_editor_file_lasttextshow = $textshow
			]

			if (> $_curtabvsts_savedfiles (- (listlen $saved_files) $files_length)) [
				_curtabvsts_savedfiles = 0
			]
			if (< $_curtabvsts_savedfiles 0) [
				_curtabvsts_savedfiles = (- (listlen $saved_files) $files_length)
			]
			guistrut -11
			guilist [
				if (> (listlen $saved_files) $files_length) [guistrut -2]
				guilist [
					_guilistscroll vsts_savedfiles $saved_files [
						local file_type
						file_type = 0
						if (!= (strstr $vsts_savedfiles ".cfg") -1) [ file_type = 1 ]
						if (!= (strstr $vsts_savedfiles ".glsl") -1) [ file_type = 2 ]
						guialign -1 [
							loop bk 17 [
								guiimage "<mad:0.1/0.1/0.1>packages/skyboxes/white_ft.jpg" [] 0.5 0
								guistrut -0.188
							]
							guistrut -30
							guitext (concatword (? (= $file_type 1) "^f1|" (? (= $file_type 2) "^f5|" "^f7")) (strreplace $vsts_savedfiles $filtered_textshow (concatword "^f2" $filtered_textshow "^f4"))) 0
						]
					] $files_length 1
				]
			]
			guistrut (+ (max 0 (- $files_length (listlen $saved_files))) 2)
		]

		guitab "^f7help"
		guilist [
			guiradio (_strstatecolor (= $_vshe_gui_help_tab 0) "What?") _vshe_gui_help_tab 0
			guistrut 1
			guiradio (_strstatecolor (= $_vshe_gui_help_tab 1) "How?") _vshe_gui_help_tab 1
			guistrut 1
			guiradio (_strstatecolor (= $_vshe_gui_help_tab 2) "Why?") _vshe_gui_help_tab 2
		]
		if (= $_vshe_gui_help_tab 0) [
			guitextbox "This menu allows you to share GLSL between players. GLSL is a type of script that allows you to change the color and position of textures. For a GLSL to work, you must specify a ^f8trigger position^f~, a ^f8trigger ID ^f~and a ^f8trigger size^f~. The effect will work as soon as your camera touches the valid trigger.^nYou can determine the shader type by inserting a ^f2//@fragment ^f~or ^f6//@vertex ^f~comment before the GLSL code.^n^nThis menu is a proof of concept just to be used as a playground, if you intend to share a map with shader effects without needing the menu, make sure to define all GLSL correctly in your map.cfg.^n^n^f~For more info: ^f1github.com/CubeScript/Sauer-Vslot-Text-Sender" 50 5 0xffffff
		]

		if (= $_vshe_gui_help_tab 1) [
			guitextbox "^f5Create: ^f~To create a GLSL simply click on the ^f8[+]^f~ button on the initial tab, the GLSL must be in the format specified by default.^n^f5Save: ^f~You can save a text file with the ^f5.glsl ^f~or ^f1.cfg^f~ extensions, these files will be stored in your home folder and can be loaded later.^n^f5Share: ^f~Locally saved GLSLs can be shared to other players by selecting a geometry and pressing the ^f2[share]^f~ button.^n^f5Allow: ^f~You can allow GLSLs created by other players by clicking ^f0[allow]^f~, or you can view and edit them by clicking ^f8[view]^f~.^n^n^f~For more info: ^f1github.com/CubeScript/Sauer-Vslot-Text-Sender" 50 5 0xffffff
		]

		if (= $_vshe_gui_help_tab 2) [
			guitextbox "Unlike the well-known ^f4/do $maptitle^f~, the shader command method allows you to store and manipulate text of extraordinary sizes quite easily within the map geometry. All text content is encoded into vslots using the vshaderparam command, and then decoded when needed. Unlike large maptitles, no vshaderparam content is lost when sending or saving the map.^n^n^f~For more info: ^f1github.com/CubeScript/Sauer-Vslot-Text-Sender" 50 5 0xffffff
		]
	]]] (format "^f8VSTS Editor ^f5#%1" $uniqueid)

	_vshe_gui_editor_description_value = $desc
	_vshe_gui_editor_body_value_preload = $body
	_vshe_gui_editor_file = (strreplace $path "../" "") // not today ;)

	sleep 30 [
		textfocus _vshe_gui_editor_body_value_preload
		textsave "vsts/lastcontent.cfg"
		textfocus _vshe_gui_editor_body_value
		textload "vsts/lastcontent.cfg"
		showgui vshe_notepad
	]
]

_vshe_gui_card_by_string_unshared = [
	@_vshe_fetch_attributes
	local escaped_desc escaped_body
	guilist [
		guibutton "^f2<[share]" [
			_vshe_share @arg1
		] 0
		guistrut 1
		guibutton "^f8[edit]" [
			_vshe_gui_notepad @arg1
		] 0
		guistrut 0.5
		guibutton "^f3[delete]" [
			_vshe_storage_local_remove @uniqueid
			_vshe_gui_local_changes_update
		] 0
	]
	guilist [
		guibutton (format "^f1#%1%2" $uniqueid (? (= $_vshe_gui_card_num 0) " ^f4(last)")) [
			_vsts_echo (format "^f5%1 ^f1#%2^f7 - %3 - ^f7by ^f8%4^f7" @path @uniqueid (escape @desc) @author)
		] 0
		
	]
	guilist [
		guitext "^f7by " 0
		guiimage (concatword "packages/icons/" (playermodelicon $model) ".jpg") [goto (getclientnum @author)] 0.5 0
		guitextbox $author 15 1 0x00ccff
	]
	guistrut -0.2
	guitext (loopconcatword s 10 [result "^f4---"]) 0
	guistrut -0.5
	_vshe_gui_card_num = (+ $_vshe_gui_card_num 1)
]

_vshe_gui_card_num = 0
_vshe_gui_help_tab = 0
_vshe_gui_card_by_string = [
	@_vshe_fetch_attributes

	guilist [
		guilist [
			if (= $_vshe_gui_card_num 0) [guistrut 1]
			if (= (_vshe_storage_local_indexof $arg1) -1) [
				guibutton "^f4off" [ _vshe_storage_local_update @arg1 ] 0
				guiimage "<grey><mad:1/0.5/0.5><rotate:2>packages/particles/base.png" [
					_vshe_storage_local_update @arg1
				] 0.5 0
				guistrut -1.05
				guialign 0 [
					guistrut -1.15
					guitext "^f4+" 0
				]
			] [
				guibutton "^f0on" [ _vshe_storage_local_remove @uniqueid ] 0
				guiimage "<grey><mad:0.5/2/0.5><rotate:2>packages/hud/blip_blue.png" [
					_vshe_storage_local_remove @uniqueid
				] 0.5 0
				guistrut -1.45
				guialign 0 [
					guistrut -1.1
					guitext "^f3_" 0
				]
			]
			guistrut -1
			guitextbox " " 3 1 0xff00ff
		]
		guistrut 1.5
		guilist [
			if (= $_vshe_gui_card_num 0) [guitextbox "shared" 12 1 0xff00ff]
			guibutton (? (= (_vshe_storage_local_indexof $arg1) -1) "^f8[view]" "^f0[edit]") [
				_vshe_gui_notepad @arg1
			] 0
			guitextbox (format "^f5[%3]^f%2#%1" $uniqueid (? (= (_vshe_storage_local_indexof $arg1) -1) 4 "~") (+ $_vshe_gui_card_num $_curtabpublic_string)) 12 1 0xaaffaa           
		]
		guistrut 1.5
		guilist [
			if (= $_vshe_gui_card_num 0) [guitextbox "author" 17 1 0xff00ff; guistrut 1] [guistrut 1]

			guilist [
				guiimage (concatword "packages/icons/" (playermodelicon $model) ".jpg") [goto (getclientnum @author)] 0.5 0
				guitextbox (strreplace $author "@@@@" "..") 14 1 (? (=s $author $name) 0xaaff00 0xff00ff)
			]
		]
	]
	_vshe_gui_card_num = (+ $_vshe_gui_card_num 1)
]

_vshe_gui_local_changes_update = [
	_vshe_gui_local_changes = (listfilter local_change $_vshe_storage_local [= (_vshe_storage_public_indexof $local_change) -1])
	_vshe_gui_local_changes = (sortlist $_vshe_gui_local_changes a b [
		local a_uniqueid b_uniqueid
		a_uniqueid = (vsts_code_to_string (vsts_attribute_get $a "uniqueid"))
		b_uniqueid = (vsts_code_to_string (vsts_attribute_get $b "uniqueid"))
		> $a_uniqueid $b_uniqueid
	])
]

_vshe_gui_auto_refresh = 1

newgui vshadereditor [guistayopen [
	if (&& (! $editing) $_vshe_gui_has_trigger_preview) [ clearpostfx ]
	guistrut 52 1
	guistrut -1
	guilist [
		guistrut -256
		guifield _vshe_gui_editor_body_value_preload 1
	]

	guilist [
		guicheckbox "" _vshe_gui_auto_refresh 1 0
		guibutton "^f8[refresh]" [
			_vshe_storage_public_load
			_vshe_gui_local_changes_update
		] 0
		if $_vshe_gui_auto_refresh [guistrut 0.5; guitext (concatword "^f4(auto " (+ (div (- $_vshe_gui_repeat_delay (getmillis 1) ) 1000) 1) "s)") 0]
	]

	if (!=s $_vshe_gui_tempwarn "") [
		guistrut -5
		guialign 0 [
			guiimage "packages/mitaman/mm-auggiedog.jpg" [] 0.5 0
			guititle $_vshe_gui_tempwarn
		]
		guistrut 4
	]

	if (= $_vshe_gui_auto_refresh 1) [
		_vshe_gui_dorepeat 5000 [
			_vshe_storage_public_load
			_vshe_gui_local_changes_update
		]
	]

	guilist [
		if (= (listlen $_vshe_storage_public) 0) [
			guialign 0 [
				guitext "^f4no shared slots to show"
			]
			guispring
		]
		if (listlen $_vshe_storage_public) [
			guialign -1 [            
				_guilistscroll public_string $_vshe_storage_public [
					_vshe_gui_card_by_string $public_string
				] 5 1
			]
			guibar
		]
		guialign -1 [
			guialign 0 [
				guititle "^f7local changes"
				guistrut 0.5
				guispring
				guibutton "^f8[+]" [
					_vshe_gui_notepad ""
				] 0
			]
			guistrut 22 1
			guialign -1 [
				guispring
				guilist [
					if (listlen $_vshe_gui_local_changes) [
						_guilistscroll unshared_string $_vshe_gui_local_changes [
							_vshe_gui_card_by_string_unshared $unshared_string
						] 3 1
					] [
						guitextbox "press ^f4[+]^f~ to create a new slot, slots you modify will appear here before they are shared." 22 1 0xaabbbb
					]
				]
			]
		]
	]

	_vshe_gui_card_num = 0
]] "^f8Vslot Text Sender ^f7(v0.1)"

vshadereditor = [
	showgui vshadereditor
	if (_vshe_gui_notepad_keep) [_vshe_gui_notepad_keep = 0; showgui vshe_notepad]
]

//vshadereditor

_vshe_mapshader_format = [
	local fragment vertex fpos vpos id 
	fpos = (strstr $arg1 "//@fragment")
	vpos = (strstr $arg1 "//@vertex")
	id = (strstr $arg1 "//@id")
	if (!= $id -1) [ id = (substr $arg1 (+ $id 5) (strstr (substr $arg1 $id) "^n")) ]
	if (= $fpos -1) [ fpos = (strlen $arg1) ]
	if (= $vpos -1) [ vpos = (strlen $arg1) ]

	if (< $fpos $vpos) [
		fragment = (substr $arg1 (+ $fpos 11) (- $vpos (+ $fpos 11)))
		vertex = (substr $arg1 (+ $vpos 10) (- (strlen $arg1) (+ $vpos 10)))
	] [
		vertex = (substr $arg1 (+ $vpos 10) (- $fpos (+ $vpos 10)))
		fragment = (substr $arg1 (+ $fpos 11) (- (strlen $arg1) (+ $fpos 11)))
	]

	local mpos fragment_scope
	mpos = (strstr $fragment "//@main")
	if (!= $mpos -1) [
		local raw_fragment
		raw_fragment = $fragment
		fragment = (substr $raw_fragment (+ $mpos 7) (- (strlen $raw_fragment) (+ $mpos 7)))
		fragment_scope = (strreplace (strreplace $raw_fragment $fragment "") "//@main" "")
	]
	result (strreplace (format "[%1 [%2] [%3] [%4]]" $id $fragment $vertex $fragment_scope) "//@" "")
]


_vshe_mapshader_trigger = []

_vshe_mapshader_trigger_generate = [
	_vshe_mapshader_trigger = []
	looplist s $_vshe_storage_local [
		local body formated_body
		body = (vsts_code_to_string (vsts_attribute_get $s "body"))
		formated_body = (_vshe_mapshader_format $body)
		append _vshe_mapshader_trigger (format "[%1 [%2] [%3] [%4]]" (at $formated_body 0 0) (at $formated_body 0 1) (at $formated_body 0 2) (at $formated_body 0 3))
	]
]

_vshe_mapshader_refresh = [
	if (getalias _vshe_mapshader_trigger_refresh) [
		_vshe_mapshader_trigger_generate
		_vshe_mapshader_trigger_refresh
	] [
		_vsts_warn "^f3error: no mapshader found, triggers will not work"
	]
]

_vshe_mapshader_uniforms = [["geometryposition" [0 0 0 0]] ["geometrypivot" [0 0 0 0]] ["trigger" [0 0 0 1]] ["triggerradius" [0.7 0 0 0]]]

_vshe_mapshader_trigger_refresh = [
	texturereset
	exec "data/default_map_settings.cfg";
	shader 0 [envmapskybox@getmillis] [
		attribute vec4 vvertex;
		attribute vec3 vnormal;
		attribute vec2 vtexcoord0, vtexcoord1, vtexcoord2;
		uniform mat4 camprojmatrix;
		uniform vec2 texgenscroll;
		varying vec2 texcoord0;
		varying vec3 normal;
		varying vec3 camvec; 
		uniform vec3 camera;
		uniform vec2 envmapscale;
		void main(void)
		{
			normal = vnormal;
			camvec = camera - vvertex.xyz; 
			gl_Position = camprojmatrix * vvertex;
			texcoord0 = vtexcoord0 + texgenscroll;
		}
	] [
		varying vec2 texcoord0;
		varying vec4 color;
		varying vec3 normal;
		varying vec3 camvec;
		uniform vec2 envmapscale;
		uniform samplerCube envmap;
		void main(void)
		{
			vec3 r = 2.0 * normal * dot(camvec, normal) - camvec;
			r.z = -r.z;
			vec3 sky = textureCube(envmap, r).rgb;
			gl_FragColor = vec4(sky, 1.0);
		}
	];
	texture 0 "textures/sky.png";

	@(looplistconcat customuniforms $_vshe_mapshader_uniforms [
		local shadername shaderparams
		shadername = (at $customuniforms 0)
		shaderparams = (at $customuniforms 1)

		format "defuniformparam %1 %2;^n" $shadername $shaderparams
	])

	shader 0 [shadertrigger@getmillis] [
		attribute vec4 vvertex;
		attribute vec3 vnormal;
		attribute vec2 vtexcoord0, vtexcoord1;
		uniform mat4 camprojmatrix;
		uniform vec3 camera, vertex_relativePivot;
		uniform float millis;
		varying vec2 texcoord0, texcoord1, is_triggered;
		varying vec3 vertex_positionOffset, normal, camvec, camdir, vertexpos;

		mat4 getRotationMatrix(float angle) {
			float c = cos(angle);
			float s = sin(angle);
			return mat4(
				vec4(c, -s, 0.0, 0.0), vec4(s,  c, 0.0, 0.0),
				vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0)
			);
		}

		void main(void)
		{
			normal = vnormal;
			camvec = camera - vvertex.xyz;
			camdir = normalize(camvec);
			vertexpos = vvertex.xyz;
			is_triggered.x = float(abs(camera.x - trigger.x) <= triggerradius.x &&
				abs(camera.y - trigger.y) <= triggerradius.y &&
				abs(camera.z - trigger.z) <= triggerradius.z);

		
			mat4 rotationMatrix = getRotationMatrix(geometryposition.w == 0 ? sin(millis*2) : mod(millis, 2.0 * 3.14159));
			vec3 vertex_relativePivot = vec3(geometrypivot.w == 1 ? geometrypivot.xyz : vvertex.xyz);

			vec4 vertex_relativePosition = vec4(vvertex.xyz - vertex_relativePivot, 0.0);
			vec4 vertex_relativeRotation = rotationMatrix * vertex_relativePosition;

			is_triggered.y = distance(vvertex.xyz, camera.xyz);

			texcoord0 = vtexcoord0;
			texcoord1 = vtexcoord1 * @lmcoordscale;

			@(looplistconcat triggerproperty $_vshe_mapshader_trigger [
				local body body_checktrigger

				body = (strreplace (at $triggerproperty 2) "position" "vertex_positionOffset")
				body = (strreplace $body "dist" "is_triggered.y")
				body = (strreplace $body "is_active" "is_triggered.x == 1 && trigger.w ==")
				if (=s (at $triggerproperty 0) "*") [
					result $body
				] [
					format "if (is_triggered.x == 1 && trigger.w == %1) { %2 }; " (at $triggerproperty 0) $body
				]
			])

			vec4 vertex_transformedPosition = vertex_relativeRotation + vec4(vertex_relativePivot + geometryposition.xyz + vertex_positionOffset.xyz, 1.0);

			gl_Position = camprojmatrix * vertex_transformedPosition;
		}
	] [
		varying vec2 texcoord0, texcoord1, is_triggered;
		varying vec3 normal, camvec, camdir, vertexpos;
		uniform sampler2D diffusemap, lightmap;
		uniform float millis;
		uniform vec4 colorparams;
		uniform vec3 camera;
		uniform mat4 camprojmatrix;

		// projects a world-space point to screen-space
		vec2 projectToScreen(vec3 worldPos, mat4 projMatrix, out bool inFront) {
			vec4 clipSpacePos = projMatrix * vec4(worldPos - camera.xyz, 1.0);

			if (clipSpacePos.w > 0.0) {
				vec3 ndc = clipSpacePos.xyz / clipSpacePos.w;
				inFront = true;
				return ndc.xy;
			}
			inFront = false;
			return vec2(-1.0);
		}

		@(looplistconcat triggerproperty $_vshe_mapshader_trigger [
			at $triggerproperty 3
		])
		
		void main(void)
		{

			vec4 diffuse = texture2D(diffusemap, texcoord0);
			vec4 maplight = texture2D(lightmap, texcoord1);

			#define alpha diffuse.a
			diffuse.rgba *= colorparams.rgba;
			
			gl_FragColor = diffuse * maplight;
			gl_FragColor.a *= alpha;
			

			@(looplistconcat triggerproperty $_vshe_mapshader_trigger [
				local body

				// syntax sugar
				body = (strreplace (at $triggerproperty 1) "color" "gl_FragColor")
				body = (strreplace $body "dist" "is_triggered.y")
				body = (strreplace $body "is_active" "is_triggered.x == 1 && trigger.w ==")
				if (=s (at $triggerproperty 0) "*") [
					result $body
				] [
					format "if (is_triggered.x == 1 && trigger.w == %1) { %2 }; " (at $triggerproperty 0) $body
				]
			])

		}

	]

	setshader [shadertrigger@getmillis];
	texture 0 "textures/default.png"
	texture 0 "textures/fatum/white.jpg"
	texture 0 "mitaman/mm-auggiedog.jpg"
	texture 0 "fonts/default0.png"
	texture 0 "hud/items.png"
	setshader [envmapskybox@getmillis];
	texture 0 "textures/sky.png";
	envmapsize 10

	_vshe_draw_box_postfx = [
		_vshe_gui_has_trigger_preview = 1
		shader 0 [conceptshader_box@getmillis] [
			attribute vec4 vvertex;
			@(screentexcoord 0)
			varying vec2 texcoord0;
			
			void main(void) {
				gl_Position = vvertex;
				texcoord0 = vtexcoord0;
			}
		] [
			uniform sampler2D tex0;
			varying vec2 texcoord0;
			varying vec4 camera;
			uniform mat4 camprojmatrix;

			uniform vec3 boxCenter = vec3(@arg1 , @arg2 , @arg3 );
			uniform vec3 boxSize   = vec3(@arg5 * 2 , @arg6 * 2 , @arg7 * 2);
			uniform vec4 outlineColor = vec4(0, 1, 1, 1.0);
			uniform vec4 faceColor = vec4(1.5, 0.0, 1.5, 0.02);

			vec2 projectToScreen(vec3 worldPos, mat4 projMatrix, out bool inFront) {
				vec4 clipSpacePos = projMatrix * vec4(worldPos - camera.xyz, 1.0);
				if (clipSpacePos.w > 0.0) {
					vec3 ndc = clipSpacePos.xyz / clipSpacePos.w;
					inFront = true;
					return ndc.xy;
				}
				inFront = false;
				return vec2(-1.0);
			}

			float distanceToSegment(vec2 p, vec2 a, vec2 b) {
				vec2 pa = p - a;
				vec2 ba = b - a;
				float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
				return length(pa - ba * h);
			}

			bool pointInQuad(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {
					float cross1 = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);
					float cross2 = (c.x - b.x) * (p.y - b.y) - (c.y - b.y) * (p.x - b.x);
					float cross3 = (d.x - c.x) * (p.y - c.y) - (d.y - c.y) * (p.x - c.x);
					float cross4 = (a.x - d.x) * (p.y - d.y) - (a.y - d.y) * (p.x - d.x);
					bool allPos = (cross1 >= 0.0) && (cross2 >= 0.0) && (cross3 >= 0.0) && (cross4 >= 0.0);
					bool allNeg = (cross1 <= 0.0) && (cross2 <= 0.0) && (cross3 <= 0.0) && (cross4 <= 0.0);
					return allPos || allNeg;
			}

			void main(void)
			{
				vec4 texColor = texture2D(tex0, texcoord0);
				vec2 screenPos = texcoord0 * 2.0 - 1.0;

				vec3 halfSize = boxSize * 0.5;
				vec3 boxVertices[8];
				boxVertices[0] = boxCenter + vec3(-halfSize.x, -halfSize.y, -halfSize.z);
				boxVertices[1] = boxCenter + vec3( halfSize.x, -halfSize.y, -halfSize.z);
				boxVertices[2] = boxCenter + vec3(-halfSize.x,  halfSize.y, -halfSize.z);
				boxVertices[3] = boxCenter + vec3( halfSize.x,  halfSize.y, -halfSize.z);
				boxVertices[4] = boxCenter + vec3(-halfSize.x, -halfSize.y,  halfSize.z);
				boxVertices[5] = boxCenter + vec3( halfSize.x, -halfSize.y,  halfSize.z);
				boxVertices[6] = boxCenter + vec3(-halfSize.x,  halfSize.y,  halfSize.z);
				boxVertices[7] = boxCenter + vec3( halfSize.x,  halfSize.y,  halfSize.z);

				ivec4 faces[6] = ivec4[6](ivec4(0, 1, 3, 2), ivec4(4, 5, 7, 6), ivec4(0, 1, 5, 4), ivec4(2, 3, 7, 6), ivec4(0, 2, 6, 4), ivec4(1, 3, 7, 5));

				vec4 finalColor = texColor;

				for (int i = 0; i < 6; i++) {
					bool inFront0, inFront1, inFront2, inFront3;
					vec2 v0 = projectToScreen(boxVertices[faces[i].x], camprojmatrix, inFront0);
					vec2 v1 = projectToScreen(boxVertices[faces[i].y], camprojmatrix, inFront1);
					vec2 v2 = projectToScreen(boxVertices[faces[i].z], camprojmatrix, inFront2);
					vec2 v3 = projectToScreen(boxVertices[faces[i].w], camprojmatrix, inFront3);

					if (inFront0 && inFront1 && inFront2 && inFront3) {
							if (pointInQuad(screenPos, v0, v1, v2, v3)) {
									finalColor = mix(faceColor, finalColor, 1.0 - faceColor.a);
							}
					}
				}

				ivec2 edges[12] = ivec2[12](
					ivec2(0, 1), ivec2(1, 3), ivec2(3, 2), ivec2(2, 0),
					ivec2(4, 5), ivec2(5, 7), ivec2(7, 6), ivec2(6, 4),
					ivec2(0, 4), ivec2(1, 5), ivec2(2, 6), ivec2(3, 7)
				);

				float d = length(boxCenter - camera.xyz);
				float minDistance = 0.005;
				float adjustedMinDistance = minDistance / (1.0 + d * 0.001);

				for (int i = 0; i < 12; i++) {
					bool v0InFront, v1InFront;
					vec2 v0Screen = projectToScreen(boxVertices[edges[i].x], camprojmatrix, v0InFront);
					vec2 v1Screen = projectToScreen(boxVertices[edges[i].y], camprojmatrix, v1InFront);
					if (v0InFront && v1InFront) {
						float dist = distanceToSegment(screenPos, v0Screen, v1Screen);
						float lineVisibility = 1.0 - smoothstep(0.0, adjustedMinDistance, dist);
						finalColor = mix(finalColor, outlineColor, lineVisibility);
					}
				}

				gl_FragColor = finalColor;
			}
		]
			
		clearpostfx
		setpostfx [conceptshader_box@getmillis]
	]
]

_guilistscroll = [local _curlist _cursublist; if (!=s $arg2 "") [nodebug [_curlist = $arg2; if (|| (> $(concatword "_curtab" $arg1) (listlen $_curlist)) (=s (getalias (concatword "_curtab" $arg1)) "")) [(concatword "_curtab" $arg1) = 0]; _cursublist = (sublist $_curlist $(concatword "_curtab" $arg1) $arg4); guilist [if (&& (|| (=s $arg5 "") (!= $arg5 0)) (> (listlen $_curlist) $arg4)) [guislider (concatword "_curtab" $arg1) (- (listlen $_curlist) $arg4) 0]; guilist [looplist $arg1 $_cursublist [arg3]; if (> (listlen $_curlist) $arg4) [loop _e (- $arg4 (listlen $_cursublist)) [guitext "" 0]]]]; arg6]] [arg7]]
_strstatecolor = [if (=s $arg3 "") [arg3 = "4"]; if (=s $arg4 "") [arg4 = "0"]; result (concatword "^f" (at [@arg3 @arg4] $arg1) $arg2)]
_strstr+ = [arg1 = (strstr (substr $arg1 $arg3) $arg2); if (>= $arg1 0) [+ $arg1 $arg3] [result -1]]
_strstrlist = [local i l idc; i = 0; l = (strlen $arg2); while [> $i -1] [i = (_strstr+ $arg1 $arg2 $i); if (>= $i 0) [append idc $i; i = (+ $i $l)]]; result $idc]

_vsts_echo "Vslot Text Sender loaded"